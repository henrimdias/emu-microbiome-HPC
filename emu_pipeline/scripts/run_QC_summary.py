#!/usr/bin/env python3
# =============================================================================
# Article:
# Dias, H.M., et al. Reproducible Emu-based workflow for high-fidelity soil and
# plant microbiome profiling on HPC clusters. Bio-protocol. 2025.
#
# Script:
# Consolidate NanoStat QC metrics (pre- and post-filter) into summary tables
# and PDF plots for the NanoTools (NanoPlot/NanoFilt) workflow.
#
# Author (script):
# Henrique M. Dias
#
# Affiliation:
# South Dakota State University
#
# Date:
# 2025
#
# Description:
# This script reads NanoStat reports generated by NanoPlot for raw (pre-filter)
# and filtered (post-filter) reads, merges their metrics into a single table,
# and produces a PDF with comparative bar plots per metric across samples.
#
# The script:
#   - Recursively scans `raw/` and `filtered/` subfolders under a QC directory
#     for *NanoStats.txt files.
#   - Parses key NanoStat metrics (mean/median length, quality, N50, etc.).
#   - Combines them into a single CSV summary.
#   - Creates a PDF with bar plots comparing pre vs post per metric.
#
# Assumptions:
#   - QC directory contains:
#       <QC_DIR>/raw/.../*NanoStats.txt
#       <QC_DIR>/filtered/.../*NanoStats.txt
#   - NanoStat outputs follow the standard text format.
#   - pandas and matplotlib are installed and available.
#
# Inputs (command-line arguments):
#   --input   : path to QC directory containing 'raw' and 'filtered' subfolders
#   --output  : path to output summary directory
#
# Outputs:
#   - sequencing_summary.csv      : combined NanoStat metrics for all samples
#   - QC_summary_plots.pdf        : comparative QC plots (pre vs post)
#
# Usage:
#   python run_QC_summary.py --input <QC_DIR> --output <SUMMARY_DIR>
#
# For full reproducibility, versions of Python, pandas, matplotlib, NanoStat,
# and related tools are documented in the manuscript / documentation.
# =============================================================================
"""
QC Summary Script for NanoPlot/NanoFilt Workflow
------------------------------------------------
This script consolidates NanoStat metrics from RAW (pre-filter)
and FILTERED (post-filter) datasets into one summary table and
multi-page PDF with comparative plots.

Usage:
  python run_QC_summary.py --input <QC_DIR> --output <SUMMARY_DIR>

Example:
  python run_QC_summary.py --input /scratch/project/02_qc \
                           --output /scratch/project/03_summary
"""

import os
import re
import glob
import argparse
import pandas as pd
import matplotlib.pyplot as plt
from matplotlib.backends.backend_pdf import PdfPages
from matplotlib.ticker import MaxNLocator

# ---------------------------------------------------------------------
# Regex patterns for NanoStat metrics
# ---------------------------------------------------------------------
METRICS = {
    "Mean read length":     r"Mean read length:\s*([\d,\.]+)",
    "Mean read quality":    r"Mean read quality:\s*([\d,\.]+)",
    "Median read length":   r"Median read length:\s*([\d,\.]+)",
    "Median read quality":  r"Median read quality:\s*([\d,\.]+)",
    "Number of reads":      r"Number of reads:\s*([\d,\.]+)",
    "Read length N50":      r"Read length N50:\s*([\d,\.]+)",
    "STDEV read length":    r"STDEV read length:\s*([\d,\.]+)",
    "Q10_count":            r">Q10:\s*([\d,]+)",
    "Q10_pct":              r">Q10:.*\(([\d\.]+)%\)",
}

# ---------------------------------------------------------------------
# Helper function
# ---------------------------------------------------------------------
def parse_report(filepath):
    """Read a NanoStat report and return {metric: value}."""
    text = open(filepath, encoding="utf8").read()
    values = {}
    for name, pattern in METRICS.items():
        m = re.search(pattern, text)
        values[name] = float(m.group(1).replace(",", "")) if m else float("nan")
    return values


def collect_reports(base_dir, label):
    """Return dataframe of all NanoStat reports from a directory."""
    reports = glob.glob(os.path.join(base_dir, "**", "*NanoStats.txt"), recursive=True)
    if not reports:
        print(f"[WARNING] No NanoStat reports found in {base_dir}")
        return pd.DataFrame()
    records = []
    for fp in reports:
        sample = os.path.basename(os.path.dirname(fp))
        metrics = parse_report(fp)
        metrics["Sample"] = sample
        metrics["Stage"] = label
        records.append(metrics)
    return pd.DataFrame(records)


# ---------------------------------------------------------------------
# Main
# ---------------------------------------------------------------------
def main():
    parser = argparse.ArgumentParser(description="Summarize NanoStat QC metrics.")
    parser.add_argument("--input", required=True, help="Path to QC directory containing 'raw' and 'filtered' subfolders.")
    parser.add_argument("--output", required=True, help="Path to output summary directory.")
    args = parser.parse_args()

    qc_dir = args.input
    out_dir = args.output
    os.makedirs(out_dir, exist_ok=True)

    pre_dir = os.path.join(qc_dir, "raw")
    post_dir = os.path.join(qc_dir, "filtered")

    print("==============================================")
    print("  NanoStat QC Summary Report")
    print("----------------------------------------------")
    print(f" Input directory : {qc_dir}")
    print(f" Output directory: {out_dir}")
    print("==============================================\n")

    # Collect pre and post tables
    df_pre = collect_reports(pre_dir, "pre")
    df_post = collect_reports(post_dir, "post")

    if df_pre.empty and df_post.empty:
        print("❌ No NanoStat reports found. Exiting.")
        return

    df_all = pd.concat([df_pre, df_post], ignore_index=True)
    df_all.to_csv(os.path.join(out_dir, "sequencing_summary.csv"), index=False)
    print(f"✅ Summary table saved: {os.path.join(out_dir, 'sequencing_summary.csv')}")

    # Pivot and compare key metrics
    pivot_cols = ["Sample", "Stage", "Mean read length", "Mean read quality",
                  "Number of reads", "Read length N50"]
    df_plot = df_all[pivot_cols].melt(id_vars=["Sample", "Stage"], var_name="Metric", value_name="Value")

    # Generate PDF report
    pdf_path = os.path.join(out_dir, "QC_summary_plots.pdf")
    with PdfPages(pdf_path) as pdf:
        for metric in df_plot["Metric"].unique():
            fig, ax = plt.subplots(figsize=(8, 5))
            sub = df_plot[df_plot["Metric"] == metric]
            sub.pivot(index="Sample", columns="Stage", values="Value").plot.bar(ax=ax)
            ax.set_title(metric)
            ax.set_ylabel("Value")
            ax.yaxis.set_major_locator(MaxNLocator(integer=False))
            plt.xticks(rotation=45, ha="right")
            plt.tight_layout()
            pdf.savefig(fig)
            plt.close(fig)
    print(f"✅ PDF summary saved: {pdf_path}")

    # Print quick summary stats
    mean_lengths = df_all.groupby("Stage")["Mean read length"].mean().round(1)
    read_counts = df_all.groupby("Stage")["Number of reads"].sum().astype(int)
    print("\nQuick summary:")
    print(mean_lengths)
    print(read_counts)
    print("\n✅ QC summary completed successfully.\n")


if __name__ == "__main__":
    main()
